import logging\nimport time\n\nfrom gatox.github.api import Api, GqlQueries\nfrom gatox.models.repository import Repository, Secret, Runner\nfrom gatox.models.organization import Organization\nfrom gatox.cli.output import Output\nfrom gatox.enumerate.repository import RepositoryEnum\nfrom gatox.enumerate.organization import OrganizationEnum\nfrom gatox.enumerate.recommender import Recommender\nfrom gatox.enumerate.ingest.ingest import DataIngestor\nfrom gatox.caching.cache_manager import CacheManager\n\nlogger = logging.getLogger(__name__)\n\nclass Enumerator:\n    """Class holding all high level logic for enumerating GitHub, whether it is\n    a user's entire access, individual organizations, or repositories.\n    """\n\n    def __init__(\n        self,\n        pat: str,\n        socks_proxy: str = None,\n        http_proxy: str = None,\n        output_yaml: str = None,\n        skip_log: bool = False,\n        github_url: str = None,\n        output_json: str = None\n    ) -> None:\n        """Initialize enumeration class with arguments sent by user.\n\n        Args:\n            pat (str): GitHub personal access token\n            socks_proxy (str, optional): Proxy settings for SOCKS proxy.\n                Defaults to None.\n            http_proxy (str, optional): Proxy settings for HTTP proxy.\n                Defaults to None.\n            output_yaml (str, optional): If set, directory to save all yml\n                files to. Defaults to None.\n            skip_log (bool, optional): If set, then run logs will not be\n                downloaded. Defaults to False.\n            github_url (str, optional): GitHub API URL. Defaults to None.\n            output_json (str, optional): JSON file to output enumeration\n                results. Defaults to None.\n        """\n        self.api = Api(\n            pat,\n            socks_proxy=socks_proxy,\n            http_proxy=http_proxy,\n            github_url=github_url,\n        )\n\n        self.socks_proxy = socks_proxy\n        self.http_proxy = http_proxy\n        self.skip_log = skip_log\n        self.output_yaml = output_yaml\n        self.user_perms = None\n        self.github_url = github_url\n        self.output_json = output_json\n\n        self.repo_e = RepositoryEnum(self.api, skip_log, output_yaml)\n        self.org_e = OrganizationEnum(self.api)\n\n    def __setup_user_info(self) -> bool:\n        """Set up user information and check permissions.\n\n        Returns:\n            bool: True if user info is successfully set up, False otherwise.\n        """\n        if not self.user_perms:\n            self.user_perms = self.api.check_user()\n            if not self.user_perms:\n                Output.error("This token cannot be used for enumeration!")\n                return False\n\n            Output.info(\n                "The authenticated user is: "\n                f"{Output.bright(self.user_perms['user'])}"\n            )\n            if self.user_perms['scopes']:\n                Output.info(\n                    "The GitHub Classic PAT has the following scopes: "\n                    f'{Output.yellow(", ".join(self.user_perms["scopes"]))}'\n                )\n            else:\n                Output.warn("The token has no scopes!")\n\n        return True\n\n    def validate_only(self) -> bool:\n        """Validates the PAT access and exits.\n\n        Returns:\n            bool: True if validation is successful, False otherwise.\n        """\n        if not self.__setup_user_info():\n            return False\n\n        if 'repo' not in self.user_perms['scopes']:\n            Output.warn("Token does not have sufficient access to list orgs!")\n            return False\n\n        orgs = self.api.check_organizations()\n\n        Output.info(\n            f'The user {self.user_perms["user"].strip()} belongs to {len(orgs)} '\n            'organizations!'\n        )\n\n        for org in orgs:\n            Output.tabbed(f"{Output.bright(org)}")\n\n        return [Organization({"login": org}, self.user_perms['scopes'], True) for org in orgs]\n\n    def self_enumeration(self) -> bool:\n        """Enumerates all organizations associated with the authenticated user.\n\n        Returns:\n            bool: False if the PAT is not valid for enumeration.\n        """\n\n        if not self.__setup_user_info():\n            return False\n\n        if not self.user_perms:\n            return False\n\n        if 'repo' not in self.user_perms['scopes']:\n            Output.error("Self-enumeration requires the repo scope!")\n            return False\n\n        orgs = self.api.check_organizations()\n\n        Output.info(\n            f'The user {self.user_perms["user"].strip()} belongs to {len(orgs)} '\n            'organizations!'\n        )\n\n        for org in orgs:\n            Output.tabbed(f"{Output.bright(org)}")\n\n        org_wrappers = list(map(self.enumerate_organization, orgs))\n\n        return org_wrappers\n\n    def enumerate_organization(self, org: str) -> Organization:\n        """Enumerate an entire organization, and check everything relevant to\n        self-hosted runner abuse that that the user has permissions to check.\n\n        Args:\n            org (str): Organization to perform enumeration on.\n\n        Returns:\n            Organization: Organization object with enumeration results.\n        """\n\n        if not self.__setup_user_info():\n            return False\n\n        details = self.api.get_organization_details(org)\n\n        if not details:\n            Output.warn(\n                f"Unable to query the org: {Output.bright(org)}! Ensure the "\n                'organization exists!'"\n            )\n            return False\n\n        organization = Organization(details, self.user_perms['scopes'])\n\n        Output.result(f"Enumerating the {Output.bright(org)} organization!")\n\n        if organization.org_admin_user and organization.org_admin_scopes:\n            self.org_e.admin_enum(organization)\n\n        Recommender.print_org_findings(\n            self.user_perms['scopes'], organization\n        )\n\n        enum_list = self.org_e.construct_repo_enum_list(organization)\n\n        Output.info(\n            f"About to enumerate "\n            f"{len(organization.private_repos) + len(organization.public_repos)}"\n            ' repos within '\n            f'the {organization.name} organization!'\n        )\n\n        Output.info('Querying and caching workflow YAML files!')\n        wf_queries = GqlQueries.get_workflow_ymls(enum_list)\n\n        for i, wf_query in enumerate(wf_queries):\n            Output.info(f'Querying {i} out of {len(wf_queries)} batches!', end='\r')\n            result = self.org_e.api.call_post('/graphql', wf_query)\n            # Sometimes we don't get a 200, fall back in this case.\n            if result.status_code == 200:\n                DataIngestor.construct_workflow_cache(result.json()['data']['nodes'])\n            else:\n                Output.warn(\n                    'GraphQL query failed, will revert to '\n                    'REST workflow query for impacted repositories!'\n                )\n        try:\n            for repo in enum_list:\n                if repo.is_archived():\n                    continue\n                if self.skip_log and repo.is_fork():\n                    continue\n                Output.tabbed(\n                    f'Enumerating: {Output.bright(repo.name)}!'\n                )\n\n                cached_repo = CacheManager().get_repository(repo.name)\n                if cached_repo:\n                    repo = cached_repo\n                \n                self.repo_e.enumerate_repository(repo, large_org_enum=len(enum_list) > 25)\n                self.repo_e.enumerate_repository_secrets(repo)\n\n                Recommender.print_repo_secrets(\n                    self.user_perms['scopes'],\n                    repo.secrets\n                )\n                Recommender.print_repo_runner_info(repo)\n                Recommender.print_repo_attack_recommendations(\n                    self.user_perms['scopes'], repo\n                )\n        except KeyboardInterrupt:\n            Output.warn('Keyboard interrupt detected, exiting enumeration!')\n\n        return organization\n\n    def enumerate_repo_only(self, repo_name: str, large_enum: bool = False) -> Repository:\n        """Enumerate only a single repository. No checks for org-level\n        self-hosted runners will be performed in this case.\n\n        Args:\n            repo_name (str): Repository name in {Org/Owner}/Repo format.\n            large_enum (bool, optional): Whether to only download\n                run logs when workflow analysis detects runners. Defaults to False.\n\n        Returns:\n            Repository: Repository object with enumeration results.\n        """\n        if not self.__setup_user_info():\n            return False\n\n        repo = CacheManager().get_repository(repo_name)\n\n        if not repo:\n            repo_data = self.api.get_repository(repo_name)\n            if repo_data:\n                repo = Repository(repo_data)\n\n        if repo:\n            if repo.is_archived():\n                Output.tabbed(\n                    f'Skipping archived repository: {Output.bright(repo.name)}!'\n                )\n                return False\n            \n            Output.tabbed(\n                    f'Enumerating: {Output.bright(repo.name)}!'\n            )\n            \n            self.repo_e.enumerate_repository(repo, large_org_enum=large_enum)\n            self.repo_e.enumerate_repository_secrets(repo)\n\n            Recommender.print_repo_secrets(\n                self.user_perms['scopes'],\n                repo.secrets + repo.org_secrets\n            )\n            Recommender.print_repo_runner_info(repo)\n            Recommender.print_repo_attack_recommendations(\n                self.user_perms['scopes'], repo\n            )\n\n            return repo\n        else:\n            Output.warn(\n                f'Unable to enumerate {Output.bright(repo_name)}! It may not '\n                'exist or the user does not have access.'\n            )\n\n    def enumerate_repos(self, repo_names: list) -> list:\n        """Enumerate a list of repositories, each repo must be in Org/Repo name\n        format.\n\n        Args:\n            repo_names (list): Repository name in {Org/Owner}/Repo format.\n\n        Returns:\n            list: List of Repository objects with enumeration results.\n        """\n        if not self.__setup_user_info():\n            return False\n\n        if not repo_names:\n            Output.error('The list of repositories was empty!')\n            return\n\n        Output.info(\n            f'Querying and caching workflow YAML files '\n            f'from {len(repo_names)} repositories!'\n        )\n        queries = GqlQueries.get_workflow_ymls_from_list(repo_names)\n\n        for i, wf_query in enumerate(queries):\n            Output.info(f'Querying {i} out of {len(queries)} batches!', end='\r')\n            try:\n                for i in range(0, 3):\n                    result = self.repo_e.api.call_post('/graphql', wf_query)\n                    if result.status_code == 200:\n                        DataIngestor.construct_workflow_cache(result.json()['data'].values())\n                        break\n                    else:\n                        Output.warn(\n                            f'GraphQL query failed with {result.status_code} '\n                            f'on attempt {str(i+1)}, will try again!'\n                        )\n                        time.sleep(10)\n                        Output.warn(f'Query size was: {len(wf_query)}')\n            except Exception as e:\n                print(e)\n                Output.warn(\n                    'GraphQL query failed, will revert to REST '\n                    'workflow query for impacted repositories!'\n                )\n\n        repo_wrappers = []\n        try:\n            for repo in repo_names:\n\n                repo_obj = self.enumerate_repo_only(repo, len(repo_names) > 100)\n                if repo_obj:\n                    repo_wrappers.append(repo_obj)\n        except KeyboardInterrupt:\n            Output.warn('Keyboard interrupt detected, exiting enumeration!')\n\n        return repo_wrappers\n