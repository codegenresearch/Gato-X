import logging\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\n\nfrom gatox.github.api import Api\nfrom gatox.github.gql_queries import GqlQueries\nfrom gatox.models.repository import Repository\nfrom gatox.models.organization import Organization\nfrom gatox.cli.output import Output\nfrom gatox.enumerate.repository import RepositoryEnum\nfrom gatox.enumerate.organization import OrganizationEnum\nfrom gatox.enumerate.recommender import Recommender\nfrom gatox.enumerate.ingest.ingest import DataIngestor\nfrom gatox.caching.cache_manager import CacheManager\n\nlogger = logging.getLogger(__name__)\n\n\nclass Enumerator:\n    """Class holding all high level logic for enumerating GitHub, whether it is\n    a user's entire access, individual organizations, or repositories.\n    """\n\n    def __init__(\n        self,\n        pat: str,\n        socks_proxy: str = None,\n        http_proxy: str = None,\n        output_yaml: str = None,\n        skip_log: bool = False,\n        github_url: str = None,\n        output_json: str = None,\n    ) -> None:\n        """Initialize enumeration class with arguments sent by user.\n\n        Args:\n            pat (str): GitHub personal access token\n            socks_proxy (str, optional): Proxy settings for SOCKS proxy.\n                Defaults to None.\n            http_proxy (str, optional): Proxy settings for HTTP proxy.\n                Defaults to None.\n            output_yaml (str, optional): Directory to save all yml\n                files to. Defaults to None.\n            skip_log (bool, optional): If set, then run logs will not be\n                downloaded. Defaults to False.\n            github_url (str, optional): GitHub URL. Defaults to None.\n            output_json (str, optional): JSON file to output enumeration\n                results. Defaults to None.\n        """\n        self.api = Api(\n            pat,\n            socks_proxy=socks_proxy,\n            http_proxy=http_proxy,\n            github_url=github_url,\n        )\n\n        self.socks_proxy = socks_proxy\n        self.http_proxy = http_proxy\n        self.skip_log = skip_log\n        self.output_yaml = output_yaml\n        self.github_url = github_url\n        self.output_json = output_json\n        self.user_perms = None\n\n        self.repo_e = RepositoryEnum(self.api, skip_log, output_yaml)\n        self.org_e = OrganizationEnum(self.api)\n\n    def __setup_user_info(self) -> bool:\n        """Sets up user/app token information.\n\n        Returns:\n            bool: True if user info is successfully set, False otherwise.\n        """\n        if not self.user_perms:\n            if self.api.is_app_token():\n                installation_info = self.api.get_installation_repos()\n                if installation_info and installation_info[\"total_count\"]:\n                    Output.info(\"Gato-X is using a valid GitHub App installation token!")\n                    self.user_perms = {\n                        \"user\": \"Github App\",\n                        \"scopes\": [],\n                        \"name\": \"GATO-X App Mode\",\n                    }\n                    return True\n                Output.error(\"No repositories found with this GitHub App installation token!")\n                return False\n\n            self.user_perms = self.api.check_user()\n            if not self.user_perms:\n                Output.error(\"This token cannot be used for enumeration!")\n                return False\n\n            Output.info(\n                \"The authenticated user is: \"\n                f\"{Output.bright(self.user_perms[\'user\'])}\"\n            )\n            if self.user_perms[\'scopes\"]:\n                Output.info(\n                    \"The GitHub Classic PAT has the following scopes: \"\n                    f\'{Output.yellow(", ".join(self.user_perms[\'scopes\']))}\'\n                )\n            else:\n                Output.warn(\"The token has no scopes!")\n\n        return True\n\n    def __query_graphql_workflows(self, queries: list) -> None:\n        """Wrapper for querying workflows using the GitHub GraphQL API.\n\n        Args:\n            queries (list): List of GraphQL queries to execute.\n        """\n        with ThreadPoolExecutor(max_workers=3) as executor:\n            Output.info(f\"Querying repositories in {len(queries)} batches!")\n            futures = [\n                executor.submit(DataIngestor.perform_query, self.api, wf_query, i)\n                for i, wf_query in enumerate(queries)\n            ]\n            for future in as_completed(futures):\n                Output.info(\n                    f\"Processed {DataIngestor.check_status()}/{len(queries)} batches.",\n                    end=\"\r\",\n                )\n                DataIngestor.construct_workflow_cache(future.result())\n\n    def validate_only(self) -> list:\n        """Validates the PAT access and exits.\n\n        Returns:\n            list: List of Organization objects if validation is successful,\n                  empty list otherwise.\n        """\n        if not self.__setup_user_info():\n            return []\n\n        if \"repo\" not in self.user_perms[\"scopes\"]:\n            Output.warn(\"Token does not have sufficient access to list orgs!")\n            return []\n\n        orgs = self.api.check_organizations()\n        if not orgs:\n            Output.warn(\"No organizations found for this token!")\n            return []\n\n        Output.info(\n            f\'The user {self.user_perms[\'user\']} belongs to {len(orgs)} organizations!\'\n        )\n        for org in orgs:\n            Output.tabbed(f\"{Output.bright(org)}\")\n\n        return [Organization({\"login\": org}, self.user_perms[\"scopes\"], True) for org in orgs]\n\n    def self_enumeration(self) -> tuple:\n        """Enumerates all organizations associated with the authenticated user.\n\n        Returns:\n            tuple: Tuple containing lists of Organization and Repository objects\n                   if enumeration is successful, empty lists otherwise.\n        """\n        if not self.__setup_user_info():\n            return [], []\n\n        if \"repo\" not in self.user_perms[\"scopes\"]:\n            Output.error(\"Self-enumeration requires the repo scope!")\n            return [], []\n\n        Output.info(\"Enumerating user owned repositories!")\n        repos = self.api.get_own_repos()\n        if not repos:\n            Output.warn(\"No repositories found for this user!")\n            return [], []\n\n        repo_wrappers = self.enumerate_repos(repos)\n        orgs = self.api.check_organizations()\n        if not orgs:\n            Output.warn(\"No organizations found for this user!")\n            return [], repo_wrappers\n\n        Output.info(\n            f\'The user {self.user_perms[\'user\']} belongs to {len(orgs)} organizations!\'\n        )\n        for org in orgs:\n            Output.tabbed(f\"{Output.bright(org)}\")\n\n        org_wrappers = list(map(self.enumerate_organization, orgs))\n        return org_wrappers, repo_wrappers\n\n    def enumerate_user(self, user: str) -> list:\n        """Enumerate a user's repositories.\n\n        Args:\n            user (str): Username of the GitHub user.\n\n        Returns:\n            list: List of Repository objects if enumeration is successful,\n                  empty list otherwise.\n        """\n        if not self.__setup_user_info():\n            return []\n\n        repos = self.api.get_user_repos(user)\n        if not repos:\n            Output.warn(\n                f\"Unable to query the user: {Output.bright(user)}! Ensure the user exists!\"\n            )\n            return []\n\n        Output.result(f\"Enumerating the {Output.bright(user)} user!")\n        return self.enumerate_repos(repos)\n\n    def enumerate_organization(self, org: str) -> Organization:\n        """Enumerate an entire organization, and check everything relevant to\n        self-hosted runner abuse that that the user has permissions to check.\n\n        Args:\n            org (str): Organization to perform enumeration on.\n\n        Returns:\n            Organization: Organization object if enumeration is successful,\n                        None otherwise.\n        """\n        if not self.__setup_user_info():\n            return None\n\n        details = self.api.get_organization_details(org)\n        if not details:\n            Output.warn(\n                f\"Unable to query the org: {Output.bright(org)}! Ensure the organization exists!\"\n            )\n            return None\n\n        organization = Organization(details, self.user_perms[\"scopes\"])\n        Output.result(f\"Enumerating the {Output.bright(org)} organization!")\n\n        if organization.org_admin_user and organization.org_admin_scopes:\n            self.org_e.admin_enum(organization)\n\n        Recommender.print_org_findings(self.user_perms[\"scopes\"])\n\n        Output.info(\"Querying repository list!")\n        enum_list = self.org_e.construct_repo_enum_list(organization)\n        if not enum_list:\n            Output.warn(\"No repositories found in this organization!")\n            return None\n\n        Output.info(\n            f\"About to enumerate {len(enum_list)} non-archived repos within \"\n            f\"the {organization.name} organization!\"\n        )\n\n        Output.info(\"Querying and caching workflow YAML files!")\n        wf_queries = GqlQueries.get_workflow_ymls(enum_list)\n        self.__query_graphql_workflows(wf_queries)\n\n        try:\n            for repo in enum_list:\n                if repo.is_archived():\n                    continue\n                if self.skip_log and repo.is_fork():\n                    continue\n                Output.tabbed(f\"Enumerating: {Output.bright(repo.name)}!")\n\n                cached_repo = CacheManager().get_repository(repo.name)\n                if cached_repo:\n                    repo = cached_repo\n\n                self.repo_e.enumerate_repository(\n                    repo, large_org_enum=len(enum_list) > 25\n                )\n                self.repo_e.enumerate_repository_secrets(repo)\n                organization.set_repository(repo)\n\n                Recommender.print_repo_secrets(self.user_perms[\"scopes\"])\n                Recommender.print_repo_runner_info(repo)\n                Recommender.print_repo_attack_recommendations(\n                    self.user_perms[\"scopes\"])\n        except KeyboardInterrupt:\n            Output.warn(\"Keyboard interrupt detected, exiting enumeration!")\n\n        return organization\n\n    def enumerate_repo_only(self, repo_name: str, large_enum: bool = False) -> Repository:\n        """Enumerate only a single repository. No checks for org-level\n        self-hosted runners will be performed in this case.\n\n        Args:\n            repo_name (str): Repository name in {Org/Owner}/Repo format.\n            large_enum (bool, optional): Whether to only download\n                run logs when workflow analysis detects runners. Defaults to False.\n\n        Returns:\n            Repository: Repository object if enumeration is successful,\n                      None otherwise.\n        """\n        if not self.__setup_user_info():\n            return None\n\n        repo = CacheManager().get_repository(repo_name)\n        if not repo:\n            repo_data = self.api.get_repository(repo_name)\n            if repo_data:\n                repo = Repository(repo_data)\n\n        if not repo:\n            Output.warn(\n                f\"Unable to enumerate {Output.bright(repo_name)}! It may not exist or the user does not have access.\"\n            )\n            return None\n\n        if repo.is_archived():\n            Output.tabbed(f\"Skipping archived repository: {Output.bright(repo.name)}!")\n            return None\n\n        Output.tabbed(f\"Enumerating: {Output.bright(repo.name)}!")\n        self.repo_e.enumerate_repository(repo, large_org_enum=large_enum)\n        self.repo_e.enumerate_repository_secrets(repo)\n        Recommender.print_repo_secrets(self.user_perms[\"scopes\"])\n        Recommender.print_repo_runner_info(repo)\n        Recommender.print_repo_attack_recommendations(\n            self.user_perms[\"scopes\"])\n        return repo\n\n    def enumerate_repos(self, repo_names: list) -> list:\n        """Enumerate a list of repositories, each repo must be in Org/Repo name\n        format.\n\n        Args:\n            repo_names (list): List of repository names in {Org/Owner}/Repo format.\n\n        Returns:\n            list: List of Repository objects if enumeration is successful,\n                  empty list otherwise.\n        """\n        if not self.__setup_user_info():\n            return []\n\n        if not repo_names:\n            Output.error(\"The list of repositories was empty!")\n            return []\n\n        Output.info(\n            f\"Querying and caching workflow YAML files from {len(repo_names)} repositories!\"\n        )\n        queries = GqlQueries.get_workflow_ymls_from_list(repo_names)\n        self.__query_graphql_workflows(queries)\n\n        repo_wrappers = []\n        try:\n            for repo in repo_names:\n                repo_obj = self.enumerate_repo_only(repo, len(repo_names) > 100)\n                if repo_obj:\n                    repo_wrappers.append(repo_obj)\n        except KeyboardInterrupt:\n            Output.warn(\"Keyboard interrupt detected, exiting enumeration!")\n\n        return repo_wrappers\n