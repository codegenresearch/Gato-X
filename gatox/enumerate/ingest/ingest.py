from gatox.caching.cache_manager import CacheManager\nfrom gatox.models.workflow import Workflow\nfrom gatox.models.repository import Repository\nfrom gatox.cli.output import Output  # Assuming Output is used for logging\n\nclass DataIngestor:\n    @staticmethod\n    def construct_workflow_cache(yml_results):\n        """Creates a cache of workflow yml files retrieved from graphQL. Since\n        graphql and REST do not have parity, we still need to use rest for most\n        enumeration calls. This method saves off all yml files, so during org level enumeration if we perform yml enumeration the cached file is used instead of making github REST requests.\n\n        Args:\n            yml_results (list): List of results from individual GraphQL queries (100 nodes at a time).\n        """\n        cache = CacheManager()\n        for result in yml_results:\n            # If we get any malformed/missing data just skip it and\n            # Gato will fall back to the contents API for these few cases.\n            if not result or 'nameWithOwner' not in result:\n                continue\n\n            owner = result['nameWithOwner']\n            cache.set_empty(owner)\n            # Empty means no yamls, so just skip.\n            if result['object']:\n                for yml_node in result['object']['entries']:\n                    yml_name = yml_node['name']\n                    if yml_name.lower().endswith(('.yml', '.yaml')):\n                        contents = yml_node['object']['text']\n                        wf_wrapper = Workflow(owner, contents, yml_name)\n\n                        cache.set_workflow(owner, yml_name, wf_wrapper)\n\n            repo_data = {\n                'full_name': result['nameWithOwner'],\n                'html_url': result['url'],\n                'visibility': 'private' if result['isPrivate'] else 'public',\n                'default_branch': result['defaultBranchRef']['name'] if result['defaultBranchRef'] else 'main',\n                'fork': result['isFork'],\n                'stargazers_count': result['stargazers']['totalCount'],\n                'pushed_at': result['pushedAt'],\n                'permissions': {\n                    'pull': result['viewerPermission'] in ['READ', 'TRIAGE', 'WRITE', 'MAINTAIN', 'ADMIN'],\n                    'push': result['viewerPermission'] in ['WRITE', 'MAINTAIN', 'ADMIN'],\n                    'admin': result['viewerPermission'] == 'ADMIN'\n                },\n                'archived': result['isArchived'],\n                'isFork': result['isFork'],\n                'environments': [],\n                'allow_forking': result['forkingAllowed']  # Using the correct field name\n            }\n\n            if 'environments' in result and result['environments']:\n                # Capture environments not named github-pages\n                envs = [env['node']['name'] for env in result['environments']['edges'] if env['node']['name'] != 'github-pages']\n                repo_data['environments'] = envs\n\n            repo_wrapper = Repository(repo_data)\n            cache.set_repository(repo_wrapper)\n\n            # Enhanced security checks for workflow triggers\n            if wf_wrapper.parsed_yml and 'on' in wf_wrapper.parsed_yml:\n                triggers = wf_wrapper.parsed_yml['on']\n                if isinstance(triggers, dict):\n                    if 'push' in triggers:\n                        branches = triggers['push'].get('branches', [])\n                        if not branches:\n                            Output.warn(f"No branches specified for push trigger in {yml_name} of {owner}")\n                elif isinstance(triggers, list):\n                    for trigger in triggers:\n                        if isinstance(trigger, dict) and 'push' in trigger:\n                            branches = trigger['push'].get('branches', [])\n                            if not branches:\n                                Output.warn(f"No branches specified for push trigger in {yml_name} of {owner}")\n\n            # Improved handling of self-hosted runner analysis\n            if repo_wrapper.environments:\n                for env in repo_wrapper.environments:\n                    if env != 'github-pages':\n                        Output.info(f"Analyzing self-hosted runners for environment {env} in {owner}")\n                        # Add logic to analyze self-hosted runners here\n