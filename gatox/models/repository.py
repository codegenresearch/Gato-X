import datetime\n\nfrom gatox.models.runner import Runner\nfrom gatox.models.secret import Secret\n\nclass Repository:\n    def __init__(self, repo_data: dict):\n        self.repo_data = repo_data\n        if 'environments' not in self.repo_data:\n            self.repo_data['environments'] = []\n\n        self.name = self.repo_data['full_name']\n        self.org_name = self.name.split('/')[0]\n        self.secrets: list[Secret] = []\n        self.org_secrets: list[Secret] = []\n        self.sh_workflow_names = []\n        self.enum_time = datetime.datetime.now()\n\n        self.permission_data = self.repo_data['permissions']\n        self.sh_runner_access = False\n        self.accessible_runners: list[Runner] = []\n        self.runners: list[Runner] = []\n        self.pwn_req_risk = []\n        self.injection_risk = []\n\n    def is_admin(self) -> bool:\n        return self.permission_data.get('admin', False)\n\n    def is_maintainer(self) -> bool:\n        return self.permission_data.get('maintain', False)\n\n    def can_push(self) -> bool:\n        return self.permission_data.get('push', False)\n\n    def can_pull(self) -> bool:\n        return self.permission_data.get('pull', False)\n\n    def is_private(self) -> bool:\n        return self.repo_data['private']\n\n    def is_archived(self) -> bool:\n        return self.repo_data['archived']\n\n    def is_internal(self) -> bool:\n        return self.repo_data['visibility'] == 'internal'\n\n    def is_public(self) -> bool:\n        return self.repo_data['visibility'] == 'public'\n\n    def is_fork(self) -> bool:\n        return self.repo_data['fork']\n\n    def can_fork(self) -> bool:\n        return self.repo_data.get('allow_forking', False)\n\n    def default_path(self) -> str:\n        return f"{self.repo_data['html_url']}/blob/{self.repo_data['default_branch']}"\n\n    def update_time(self):\n        self.enum_time = datetime.datetime.now()\n\n    def set_accessible_org_secrets(self, secrets: list[Secret]):\n        self.org_secrets = secrets\n\n    def set_pwn_request(self, pwn_request_package: dict):\n        self.pwn_req_risk.append(pwn_request_package)\n\n    def clear_pwn_request(self, workflow_name: str):\n        self.pwn_req_risk = [element for element in self.pwn_req_risk if element['workflow_name'] != workflow_name]\n\n    def has_pwn_request(self) -> bool:\n        return len(self.pwn_req_risk) > 0\n\n    def set_injection(self, injection_package: dict):\n        self.injection_risk.append(injection_package)\n\n    def has_injection(self) -> bool:\n        return len(self.injection_risk) > 0\n\n    def set_secrets(self, secrets: list[Secret]):\n        self.secrets = secrets\n\n    def set_runners(self, runners: list[Runner]):\n        self.sh_runner_access = True\n        self.runners = runners\n\n    def add_self_hosted_workflows(self, workflows: list):\n        self.sh_workflow_names.extend(workflows)\n\n    def add_accessible_runner(self, runner: Runner):\n        self.sh_runner_access = True\n        self.accessible_runners.append(runner)\n\n    def toJSON(self) -> dict:\n        return {\