import datetime\nimport logging\n\nfrom gatox.models.runner import Runner\nfrom gatox.models.secret import Secret\n\n\nclass Repository():\n    """Simple wrapper class to provide accessor methods against the repository\n    JSON response from GitHub.\n    """\n\n    def __init__(self, repo_json):\n        """Initialize wrapper class.\n\n        Args:\n            repo_json (dict): Dictionary from parsing JSON object returned from\n            GitHub\n        """\n        self.repo_data = repo_json\n        # Temporary hack until full transition to GQL\n        if 'environments' not in self.repo_data:\n            self.repo_data['environments'] = []\n\n        self.name = self.repo_data['full_name']\n        self.org_name = self.name.split('/')[0]\n        self.secrets = []\n        self.org_secrets = []\n        self.sh_workflow_names = []\n        self.enum_time = datetime.datetime.now()\n\n        self.permission_data = self.repo_data['permissions']\n        self.sh_runner_access = False\n        self.accessible_runners = []\n        self.runners = []\n        self.pwn_req_risk = []\n        self.injection_risk = []\n\n    def is_admin(self):\n        return self.permission_data.get('admin', False)\n\n    def is_maintainer(self):\n        return self.permission_data.get('maintain', False)\n\n    def can_push(self):\n        return self.permission_data.get('push', False)\n\n    def can_pull(self):\n        return self.permission_data.get('pull', False)\n\n    def is_private(self):\n        return self.repo_data['visibility'] != 'public'\n\n    def is_archived(self):\n        return self.repo_data['archived']\n\n    def is_internal(self):\n        return self.repo_data['visibility'] == 'internal'\n\n    def is_public(self):\n        return self.repo_data['visibility'] == 'public'\n\n    def is_fork(self):\n        return self.repo_data['fork']\n\n    def can_fork(self):\n        return self.repo_data.get('allow_forking', False)\n\n    def default_path(self):\n        return f"{self.repo_data['html_url']}/blob/{self.repo_data['default_branch']}"\n\n    def update_time(self):\n        self.enum_time = datetime.datetime.now()\n\n    def set_accessible_org_secrets(self, secrets):\n        self.org_secrets = secrets\n\n    def set_pwn_request(self, pwn_request_package):\n        self.pwn_req_risk.append(pwn_request_package)\n\n    def clear_pwn_request(self, workflow_name):\n        self.pwn_req_risk = [element for element in self.pwn_req_risk if element['workflow_name'] != workflow_name]\n\n    def has_pwn_request(self):\n        return len(self.pwn_req_risk) > 0\n\n    def set_injection(self, injection_package):\n        self.injection_risk.append(injection_package)\n\n    def has_injection(self):\n        return len(self.injection_risk) > 0\n\n    def set_secrets(self, secrets):\n        self.secrets = secrets\n\n    def set_runners(self, runners):\n        self.sh_runner_access = True\n        self.runners = runners\n\n    def add_self_hosted_workflows(self, workflows):\n        self.sh_workflow_names.extend(workflows)\n\n    def add_accessible_runner(self, runner):\n        self.sh_runner_access = True\n        self.accessible_runners.append(runner)\n\n    def toJSON(self):\n        return {\n            'name': self.name,\n            'enum_time': self.enum_time.ctime(),\n            'permissions': self.permission_data,\n            'can_fork': self.can_fork(),\n            'stars': self.repo_data['stargazers_count'],\n            'runner_workflows': self.sh_workflow_names,\n            'accessible_runners': [runner.toJSON() for runner in self.accessible_runners],\n            'repo_runners': [runner.toJSON() for runner in self.runners],\n            'repo_secrets': [secret.toJSON() for secret in self.secrets],\n            'org_secrets': [secret.toJSON() for secret in self.org_secrets],\n            'pwn_request_risk': self.pwn_req_risk,\n            'injection_risk': self.injection_risk\n        }\n