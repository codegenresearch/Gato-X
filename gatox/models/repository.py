import datetime\nimport logging\n\nfrom gatox.models.runner import Runner\nfrom gatox.models.secret import Secret\n\n\nclass Repository():\n    """Simple wrapper class to provide accessor methods against the repository\n    JSON response from GitHub.\n    """\n\n    def __init__(self, repo_data: dict):\n        """Initialize wrapper class.\n\n        Args:\n            repo_data (dict): Dictionary from parsing JSON object returned from\n            GitHub\n        """\n        self.repo_data = repo_data\n        # Temporary hack until full transition to GQL\n        if 'environments' not in self.repo_data:\n            self.repo_data['environments'] = []\n\n        self.name = self.repo_data['full_name']\n        self.org_name = self.name.split('/')[0]\n        self.secrets: list[Secret] = []\n        self.org_secrets: list[Secret] = []\n        self.sh_workflow_names = []\n        self.enum_time = datetime.datetime.now()\n\n        self.permission_data = self.repo_data['permissions']\n        self.sh_runner_access = False\n        self.accessible_runners: list[Runner] = []\n        self.runners: list[Runner] = []\n        self.pwn_req_risk = []\n        self.injection_risk = []\n\n    def is_admin(self) -> bool:\n        """Check if the user has admin permissions.\n\n        Returns:\n            bool: True if the user has admin permissions, False otherwise.\n        """\n        return self.permission_data.get('admin', False)\n\n    def is_maintainer(self) -> bool:\n        """Check if the user has maintainer permissions.\n\n        Returns:\n            bool: True if the user has maintainer permissions, False otherwise.\n        """\n        return self.permission_data.get('maintain', False)\n\n    def can_push(self) -> bool:\n        """Check if the user can push to the repository.\n\n        Returns:\n            bool: True if the user can push, False otherwise.\n        """\n        return self.permission_data.get('push', False)\n\n    def can_pull(self) -> bool:\n        """Check if the user can pull from the repository.\n\n        Returns:\n            bool: True if the user can pull, False otherwise.\n        """\n        return self.permission_data.get('pull', False)\n\n    def is_private(self) -> bool:\n        """Check if the repository is private.\n\n        Returns:\n            bool: True if the repository is private, False otherwise.\n        """\n        return not self.repo_data['visibility'] == 'public'\n\n    def is_archived(self) -> bool:\n        """Check if the repository is archived.\n\n        Returns:\n            bool: True if the repository is archived, False otherwise.\n        """\n        return self.repo_data['archived']\n\n    def is_internal(self) -> bool:\n        """Check if the repository is internal.\n\n        Returns:\n            bool: True if the repository is internal, False otherwise.\n        """\n        return self.repo_data['visibility'] == 'internal'\n\n    def is_public(self) -> bool:\n        """Check if the repository is public.\n\n        Returns:\n            bool: True if the repository is public, False otherwise.\n        """\n        return self.repo_data['visibility'] == 'public'\n\n    def is_fork(self) -> bool:\n        """Check if the repository is a fork.\n\n        Returns:\n            bool: True if the repository is a fork, False otherwise.\n        """\n        return self.repo_data['fork']\n\n    def can_fork(self) -> bool:\n        """Check if the repository can be forked.\n\n        Returns:\n            bool: True if the repository can be forked, False otherwise.\n        """\n        return self.repo_data.get('allow_forking', False)\n\n    def default_path(self) -> str:\n        """Get the default path for the repository.\n\n        Returns:\n            str: The default path URL.\n        """\n        return f"{self.repo_data['html_url']}/blob/{self.repo_data['default_branch']}"\n\n    def update_time(self):\n        """Update the enumeration timestamp."""\n        self.enum_time = datetime.datetime.now()\n\n    def set_accessible_org_secrets(self, secrets: list[Secret]):\n        """Set organization secrets that can be read using a workflow in\n        this repository.\n\n        Args:\n            secrets (List[Secret]): List of Secret wrapper objects.\n        """\n        self.org_secrets = secrets\n\n    def set_pwn_request(self, pwn_request_package: dict):\n        """Set a pwn request risk package.\n\n        Args:\n            pwn_request_package (dict): The pwn request package to set.\n        """\n        self.pwn_req_risk.append(pwn_request_package)\n\n    def clear_pwn_request(self, workflow_name: str):\n        """Remove a pwn request entry since it's a false positive.\n\n        Args:\n            workflow_name (str): The name of the workflow to clear.\n        """\n        self.pwn_req_risk = [element for element in self.pwn_req_risk if element['workflow_name'] != workflow_name]\n\n    def has_pwn_request(self) -> bool:\n        """Check if there are any pwn request risks.\n\n        Returns:\n            bool: True if there are any pwn request risks, False otherwise.\n        """\n        return len(self.pwn_req_risk) > 0\n\n    def set_injection(self, injection_package: dict):\n        """Set an injection risk package.\n\n        Args:\n            injection_package (dict): The injection risk package to set.\n        """\n        self.injection_risk.append(injection_package)\n\n    def has_injection(self) -> bool:\n        """Check if there are any injection risks.\n\n        Returns:\n            bool: True if there are any injection risks, False otherwise.\n        """\n        return len(self.injection_risk) > 0\n\n    def set_secrets(self, secrets: list[Secret]):\n        """Set secrets that are attached to this repository.\n\n        Args:\n            secrets (List[Secret]): List of repo level secret wrapper objects.\n        """\n        self.secrets = secrets\n\n    def set_runners(self, runners: list[Runner]):\n        """Set list of self-hosted runners attached at the repository level.\n\n        Args:\n            runners (List[Runner]): List of Runner wrapper objects.\n        """\n        self.sh_runner_access = True\n        self.runners = runners\n\n    def add_self_hosted_workflows(self, workflows: list):\n        """Add a list of workflow file names that run on self-hosted runners.\n\n        Args:\n            workflows (list): List of workflow names.\n        """\n        self.sh_workflow_names.extend(workflows)\n\n    def add_accessible_runner(self, runner: Runner):\n        """Add a runner that is accessible by this repo. This runner could be org\n        level or repo level.\n\n        Args:\n            runner (Runner): Runner wrapper object\n        """\n        self.sh_runner_access = True\n        self.accessible_runners.append(runner)\n\n    def toJSON(self) -> dict:\n        """Converts the repository to a Gato JSON representation.\n\n        Returns:\n            dict: JSON representation of the repository.\n        """\n        representation = {\n            "name": self.name,\n            "enum_time": self.enum_time.ctime(),\n            "permissions": self.permission_data,\n            "can_fork": self.can_fork(),\n            "stars": self.repo_data['stargazers_count'],\n            "runner_workflows": self.sh_workflow_names,\n            "accessible_runners": [runner.toJSON() for runner in self.accessible_runners],\n            "repo_runners": [runner.toJSON() for runner in self.runners],\n            "repo_secrets": [secret.toJSON() for secret in self.secrets],\n            "org_secrets": [secret.toJSON() for secret in self.org_secrets],\n            "pwn_request_risk": self.pwn_req_risk,\n            "injection_risk": self.injection_risk\n        }\n\n        return representation\n