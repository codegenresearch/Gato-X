import os\nimport pathlib\nimport pytest\nfrom unittest import mock\nfrom gatox.cli import cli\nfrom gatox.util.arg_utils import read_file_and_validate_lines, is_valid_directory\nfrom gatox.enumerate.enumerate import repo_wrappers\n\nrepo_wrappers()\n\n@pytest.fixture(autouse=True)\ndef mock_settings_env_vars():\n    with mock.patch.dict(os.environ, {\n        "GH_TOKEN": "ghp_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"\n    }):\n        yield\n\ndef test_cli_no_gh_token(capfd):\n    """Test case where no GH Token is provided."""\n    del os.environ["GH_TOKEN"]\n    with pytest.raises(OSError) as excinfo:\n        cli.cli(["enumerate", "-t", "test"])\n    assert "Please enter" in str(excinfo.value)\n\ndef test_cli_fine_grained_pat(capfd):\n    """Test case where an unsupported PAT is provided."""\n    os.environ["GH_TOKEN"] = "github_pat_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"\n    with pytest.raises(SystemExit) as excinfo:\n        cli.cli(["enumerate", "-t", "test"])\n    assert "not supported" in str(excinfo.value)\n\ndef test_cli_s2s_token(capfd):\n    """Test case where a service-to-service token is provided."""\n    os.environ["GH_TOKEN"] = "ghs_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"\n    with pytest.raises(SystemExit) as excinfo:\n        cli.cli(["enumerate", "-t", "test"])\n    assert "not support App tokens without machine flag" in str(excinfo.value)\n\ndef test_cli_s2s_token_no_machine(capfd):\n    """Test case where a service-to-service token is provided."""\n    os.environ["GH_TOKEN"] = "ghs_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"\n    with pytest.raises(SystemExit) as excinfo:\n        cli.cli(["enumerate", "-r", "testOrg/testRepo"])\n    assert "not support App tokens without machine flag" in str(excinfo.value)\n\ndef test_cli_s2s_token_machine(capfd):\n    """Test case where a service-to-service token is provided."""\n    os.environ["GH_TOKEN"] = "ghs_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"\n    cli.cli(["enumerate", "-r", "testOrg/testRepo", "--machine"])\n    out, err = capfd.readouterr()\n    assert "Allowing the use of a GitHub App token for single repo enumeration" in out\n\ndef test_cli_u2s_token(capfd):\n    """Test case where a service-to-service token is provided."""\n    os.environ["GH_TOKEN"] = "ghu_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"\n    with pytest.raises(SystemExit) as excinfo:\n        cli.cli(["enumerate", "-t", "test"])\n    assert "Provided GitHub PAT is malformed or unsupported" in str(excinfo.value)\n\n@mock.patch("gatox.cli.cli.Enumerator")\ndef test_cli_oauth_token(mock_enumerator, capfd):\n    """Test case where a GitHub oauth token is provided."""\n    os.environ["GH_TOKEN"] = "gho_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"\n    mock_instance = mock_enumerator.return_value\n    mock_api = mock.MagicMock()\n    mock_api.check_user.return_value = {\n        "user": "testUser",\n        "scopes": ["repo", "workflow"],\n    }\n    mock_api.get_user_type.return_value = "Organization"\n    mock_instance.api = mock_api\n\n    cli.cli(["enumerate", "-t", "test"])\n    out, err = capfd.readouterr()\n\n    mock_instance.enumerate_organization.assert_called_once()\n\n@mock.patch("gatox.cli.cli.Enumerator")\ndef test_cli_old_token(mock_enumerator, capfd):\n    """Test case where an old, but still potentially valid GitHub token is provided."""\n    os.environ["GH_TOKEN"] = "43255147468edf32a206441ad296ce648f44ee32"\n    mock_instance = mock_enumerator.return_value\n    mock_api = mock.MagicMock()\n    mock_api.check_user.return_value = {\n        "user": "testUser",\n        "scopes": ["repo", "workflow"],\n    }\n    mock_api.get_user_type.return_value = "Organization"\n    mock_instance.api = mock_api\n\n    cli.cli(["enumerate", "-t", "test"])\n    out, err = capfd.readouterr()\n\n    mock_instance.enumerate_organization.assert_called_once()\n\ndef test_cli_invalid_pat(capfd):\n    """Test case where a clearly invalid PAT is provided."""\n    os.environ["GH_TOKEN"] = "invalid"\n    with pytest.raises(SystemExit) as excinfo:\n        cli.cli(["enumerate", "-t", "test"])\n    assert "malformed" in str(excinfo.value)\n\ndef test_cli_double_proxy(capfd):\n    """Test case where conflicing proxies are provided."""\n    with pytest.raises(SystemExit) as excinfo:\n        cli.cli(["-sp", "socks", "-p", "http", "enumerate", "-t", "test"])\n    assert "proxy at the same time" in str(excinfo.value)\n\ndef test_attack_bad_args1(capfd):\n    """Test attack command without the attack method."""\n    with pytest.raises(SystemExit) as excinfo:\n        cli.cli(["attack", "-t", "test"])\n    assert "must select one" in str(excinfo.value)\n\ndef test_attack_bad_args2(capfd):\n    """Test attack command with conflicting params."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n\n    with pytest.raises(SystemExit) as excinfo:\n        cli.cli([\n            "attack",\n            "-t",\n            "test",\n            "-pr",\n            "-f",\n            os.path.join(curr_path, "files/main.yaml"),\n            "-n",\n            "invalid",\n        ])\n    assert "cannot be used with a custom" in str(excinfo.value)\n\ndef test_attack_invalid_path(capfd):\n    """Test attack command with an invalid path."""\n    with pytest.raises(SystemExit) as excinfo:\n        cli.cli(["attack", "-t", "test", "-pr", "-f", "path"])\n    assert "argument --custom-file/-f: The file: path does not exist!" in str(excinfo.value)\n\ndef test_repos_file_good():\n    """Test that the good file is validated without errors."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n\n    res = read_file_and_validate_lines(\n        os.path.join(curr_path, "files/test_repos_good.txt"),\n        r"[A-Za-z0-9-_.]+\/[A-Za-z0-9-_.]+",\n    )\n\n    assert "someorg/somerepository" in res\n    assert "some_org/some-repo" in res\n\ndef test_repos_file_bad(capfd):\n    """Test that the good file is validated without errors."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n\n    with pytest.raises(SystemExit) as excinfo:\n        cli.cli([\n            "enumerate",\n            "-R",\n            os.path.join(curr_path, "files/test_repos_bad.txt"),\n        ])\n    assert "invalid repository name!" in str(excinfo.value)\n\ndef test_valid_dir():\n    """Test that the directory validation function works."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n    mock_parser = mock.MagicMock()\n\n    res = is_valid_directory(mock_parser, os.path.join(curr_path, "files/"))\n\n    assert res == os.path.join(curr_path, "files/")\n\ndef test_invalid_dir(capfd):\n    """Test that the directory validation function works."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n    mock_parser = mock.MagicMock()\n\n    res = is_valid_directory(mock_parser, os.path.join(curr_path, "invaliddir/"))\n\n    assert res is None\n\n    mock_parser.error.assert_called_with(\n        "The directory {} does not exist!".format(\n            os.path.join(curr_path, "invaliddir/")\n        )\n    )\n\n@mock.patch("gatox.attack.runner.webshell.WebShell.runner_on_runner")\ndef test_attack_pr(mock_attack):\n    """Test attack command using the pr method."""\n    cli.cli([\n        "attack",\n        "-t",\n        "test",\n        "-pr",\n        "--target-os",\n        "linux",\n        "--target-arch",\n        "x64",\n    ])\n    mock_attack.assert_called_once()\n\n@mock.patch("gatox.attack.runner.webshell.WebShell.runner_on_runner")\ndef test_attack_pr_bados(mock_attack, capfd):\n    """Test attack command using the pr method."""\n    with pytest.raises(SystemExit) as excinfo:\n        cli.cli([\n            "attack",\n            "-t",\n            "test",\n            "-pr",\n            "--target-os",\n            "solaris",\n            "--target-arch",\n            "x64",\n        ])\n    assert "invalid choice: 'solaris'" in str(excinfo.value)\n\n@mock.patch("gatox.attack.attack.Attacker.push_workflow_attack")\ndef test_attack_workflow(mock_attack):\n    """Test attack command using the workflow method."""\n    cli.cli(["attack", "-t", "test", "-w"])\n    mock_attack.assert_called_once()\n\n@mock.patch("os.path.isdir")\ndef test_enum_bad_args1(mock_dircheck, capfd):\n    """Test enum command with invalid output location."""\n    mock_dircheck.return_value = False\n\n    with pytest.raises(SystemExit) as excinfo:\n        cli.cli(["enum", "-o", "invalid"])\n    assert "--output-yaml/-o: The directory: invalid does not exist!" in str(excinfo.value)\n\ndef test_enum_bad_args2(capfd):\n    """Test enum command without a type selection."""\n    with pytest.raises(SystemExit) as excinfo:\n        cli.cli(["enum"])\n    assert "type was specified" in str(excinfo.value)\n\ndef test_enum_bad_args3(capfd):\n    """Test enum command with multiple type selections."""\n    with pytest.raises(SystemExit) as excinfo:\n        cli.cli(["enum", "-t", "test", "-r", "testorg/test2"])\n    assert "select one enumeration" in str(excinfo.value)\n\n@mock.patch("gatox.enumerate.enumerate.Enumerator.self_enumeration")\ndef test_enum_self(mock_enumerate):\n    """Test enum command using the self enumeration."""\n    mock_enumerate.return_value = (["org1"], ["org2"])\n    cli.cli(["enum", "-s"])\n    mock_enumerate.assert_called_once()\n\n@mock.patch("gatox.cli.cli.Enumerator")\ndef test_enum_org(mock_enumerator):\n    """Test enum command using the organization enumeration."""\n    mock_instance = mock_enumerator.return_value\n    mock_api = mock.MagicMock()\n    mock_api.check_user.return_value = {\n        "user": "testUser",\n        "scopes": ["repo", "workflow"],\n    }\n    mock_api.get_user_type.return_value = "Organization"\n    mock_instance.api = mock_api\n\n    cli.cli(["enum", "-t", "test"])\n    mock_instance.enumerate_organization.assert_called_once()\n\n@mock.patch("gatox.cli.cli.Enumerator")\ndef test_enum_user(mock_enumerator):\n    """Test enum command using the organization enumeration."""\n    mock_instance = mock_enumerator.return_value\n    mock_api = mock.MagicMock()\n    mock_api.check_user.return_value = {\n        "user": "testUser",\n        "scopes": ["repo", "workflow"],\n    }\n    mock_api.get_user_type.return_value = "User"\n    mock_instance.api = mock_api\n\n    cli.cli(["enum", "-t", "testUser"])\n    mock_instance.enumerate_user.assert_called_once()\n\n@mock.patch("gatox.enumerate.enumerate.Enumerator.enumerate_repos")\n@mock.patch("gatox.util.read_file_and_validate_lines")\ndef test_enum_repos(mock_read, mock_enumerate):\n    """Test enum command using the repo list."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n    mock_read.return_value = ["repos"]\n\n    cli.cli(["enum", "-R", os.path.join(curr_path, "files/test_repos_good.txt")])\n    mock_read.assert_called_once_with(os.path.join(curr_path, "files/test_repos_good.txt"), r"[A-Za-z0-9-_.]+\/[A-Za-z0-9-_.]+")\n    mock_enumerate.assert_called_once_with(["repos"])\n\n@mock.patch("gatox.enumerate.enumerate.Enumerator.enumerate_repos")\ndef test_enum_repo(mock_enumerate):\n    """Test enum command using the organization enumeration."""\n    cli.cli(["enum", "-r", "testorg/testrepo"])\n    mock_enumerate.assert_called_once_with(["testorg/testrepo"])\n\n@mock.patch("gatox.search.search.Searcher.use_search_api")\ndef test_search(mock_search):\n    """Test search command."""\n    cli.cli(["search", "-t", "test"])\n    mock_search.assert_called_once()\n\ndef test_long_repo_name(capfd):\n    """Test enum command using name that is too long."""\n    repo_name = "Org/" + "A" * 80\n    with pytest.raises(SystemExit) as excinfo:\n        cli.cli(["enum", "-r", repo_name])\n    assert "The maximum length is 79 characters!" in str(excinfo.value)\n\ndef test_invalid_repo_name(capfd):\n    """Test enum command using invalid full repo name."""\n    with pytest.raises(SystemExit) as excinfo:\n        cli.cli(["enum", "-r", "RepoWithoutOrg"])\n    assert (\n        "argument --repository/-r: The argument is not in the valid format!" in str(excinfo.value)\n    )\n\n@mock.patch("gatox.util.arg_utils.os.access")\ndef test_unreadable_file(mock_access, capfd):\n    """Test enum command unreadable file."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n    mock_access.return_value = False\n    with pytest.raises(SystemExit) as excinfo:\n        cli.cli(["enum", "-R", os.path.join(curr_path, "files/bad_dir/bad_file")])\n    assert " is not readable" in str(excinfo.value)\n\n@mock.patch("gatox.util.arg_utils.os.access")\ndef test_unwritable_dir(mock_access, capfd):\n    """Test enum command unwritable dir."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n    mock_access.return_value = False\n    with pytest.raises(SystemExit) as excinfo:\n        cli.cli([\n            "enum",\n            "-r",\n            "testOrg/testRepo",\n            "-o",\n            os.path.join(curr_path, "files/bad_dir"),\n        ])\n    assert " is not writeable" in str(excinfo.value)\n\n@mock.patch("gatox.enumerate.enumerate.Enumerator.enumerate_repos")\ndef test_enum_repos_empty(mock_enumerate, capfd):\n    """Test enum command with an empty list of repositories."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n    mock_read = mock.MagicMock(return_value=[])\n    with mock.patch("gatox.util.read_file_and_validate_lines", mock_read):\n        cli.cli(["enum", "-R", os.path.join(curr_path, "files/test_repos_empty.txt")])\n    mock_enumerate.assert_not_called()\n    out, _ = capfd.readouterr()\n    assert "The list of repositories was empty!" in out\n