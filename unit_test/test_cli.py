import os\nimport pathlib\nimport pytest\nfrom unittest import mock\n\n# Standard library imports\nimport os\nimport pathlib\nimport pytest\nfrom unittest import mock\n\n# Third-party imports\nfrom gatox.cli import cli\nfrom gatox.util.arg_utils import read_file_and_validate_lines, is_valid_directory\nfrom gatox.enumerate.enumerate import repo_wrappers\n\nrepo_wrappers()\n\n@pytest.fixture(autouse=True)\ndef mock_settings_env_vars(request):\n    with mock.patch.dict(\n        os.environ, {"GH_TOKEN": "ghp_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"}\n    ):\n        yield\n\ndef test_cli_no_gh_token(capfd):\n    """Test case where no GH Token is provided."""\n    del os.environ["GH_TOKEN"]\n    with pytest.raises(OSError):\n        cli.cli(["enumerate", "-t", "test"])\n    out, err = capfd.readouterr()\n    assert "Please enter" in out\n\ndef test_cli_fine_grained_pat(capfd):\n    """Test case where an unsupported PAT is provided."""\n    os.environ["GH_TOKEN"] = "github_pat_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"\n    with pytest.raises(SystemExit):\n        cli.cli(["enumerate", "-t", "test"])\n    out, err = capfd.readouterr()\n    assert "not supported" in err\n\ndef test_cli_s2s_token(capfd):\n    """Test case where a service-to-service token is provided."""\n    os.environ["GH_TOKEN"] = "ghs_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"\n    with pytest.raises(SystemExit):\n        cli.cli(["enumerate", "-t", "test"])\n    out, err = capfd.readouterr()\n    assert "not support App tokens without machine flag" in err\n\ndef test_cli_s2s_token_no_machine(capfd):\n    """Test case where a service-to-service token is provided."""\n    os.environ["GH_TOKEN"] = "ghs_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"\n    with pytest.raises(SystemExit):\n        cli.cli(["enumerate", "-r", "testOrg/testRepo"])\n    out, err = capfd.readouterr()\n    assert "not support App tokens without machine flag" in err\n\ndef test_cli_s2s_token_machine(capfd):\n    """Test case where a service-to-service token is provided."""\n    os.environ["GH_TOKEN"] = "ghs_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"\n    cli.cli(["enumerate", "-r", "testOrg/testRepo", "--machine"])\n    out, err = capfd.readouterr()\n    assert "Allowing the use of a GitHub App token for single repo enumeration" in out\n\ndef test_cli_u2s_token(capfd):\n    """Test case where a service-to-service token is provided."""\n    os.environ["GH_TOKEN"] = "ghu_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"\n    with pytest.raises(SystemExit):\n        cli.cli(["enumerate", "-t", "test"])\n    out, err = capfd.readouterr()\n    assert "Provided GitHub PAT is malformed or unsupported" in err\n\n@mock.patch("gatox.cli.cli.Enumerator")\ndef test_cli_oauth_token(mock_enumerator, capfd):\n    """Test case where a GitHub oauth token is provided."""\n    os.environ["GH_TOKEN"] = "gho_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"\n    mock_instance = mock_enumerator.return_value\n    mock_api = mock.MagicMock()\n    mock_api.check_user.return_value = {\n        "user": "testUser",\n        "scopes": ["repo", "workflow"],\n    }\n    mock_api.get_user_type.return_value = "Organization"\n    mock_instance.api = mock_api\n\n    cli.cli(["enumerate", "-t", "test"])\n    out, err = capfd.readouterr()\n\n    mock_instance.enumerate_organization.assert_called_once()\n\n@mock.patch("gatox.cli.cli.Enumerator")\ndef test_cli_old_token(mock_enumerator, capfd):\n    """Test case where an old, but still potentially valid GitHub token is provided."""\n    os.environ["GH_TOKEN"] = "43255147468edf32a206441ad296ce648f44ee32"\n    mock_instance = mock_enumerator.return_value\n    mock_api = mock.MagicMock()\n    mock_api.check_user.return_value = {\n        "user": "testUser",\n        "scopes": ["repo", "workflow"],\n    }\n    mock_api.get_user_type.return_value = "Organization"\n    mock_instance.api = mock_api\n\n    cli.cli(["enumerate", "-t", "test"])\n    out, err = capfd.readouterr()\n\n    mock_instance.enumerate_organization.assert_called_once()\n\ndef test_cli_invalid_pat(capfd):\n    """Test case where a clearly invalid PAT is provided."""\n    os.environ["GH_TOKEN"] = "invalid"\n    with pytest.raises(SystemExit):\n        cli.cli(["enumerate", "-t", "test"])\n    out, err = capfd.readouterr()\n    assert "malformed" in err\n\ndef test_cli_double_proxy(capfd):\n    """Test case where conflicting proxies are provided."""\n    with pytest.raises(SystemExit):\n        cli.cli(["-sp", "socks", "-p", "http", "enumerate", "-t", "test"])\n    out, err = capfd.readouterr()\n    assert "proxy at the same time" in err\n\ndef test_attack_bad_args1(capfd):\n    """Test attack command without the attack method."""\n    with pytest.raises(SystemExit):\n        cli.cli(["attack", "-t", "test"])\n    out, err = capfd.readouterr()\n    assert "must select one" in err\n\ndef test_attack_bad_args2(capfd):\n    """Test attack command with conflicting params."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n\n    with pytest.raises(SystemExit):\n        cli.cli(\n            [\n                "attack",\n                "-t",\n                "test",\n                "-pr",\n                "-f",\n                os.path.join(curr_path, "files/main.yaml"),\n                "-n",\n                "invalid",\n            ]\n        )\n    out, err = capfd.readouterr()\n    assert "cannot be used with a custom" in err\n\ndef test_attack_invalid_path(capfd):\n    """Test attack command with an invalid path."""\n    with pytest.raises(SystemExit):\n        cli.cli(["attack", "-t", "test", "-pr", "-f", "path"])\n    out, err = capfd.readouterr()\n    assert "argument --custom-file/-f: The file: path does not exist!" in err\n\ndef test_repos_file_good():\n    """Test that the good file is validated without errors."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n\n    res = read_file_and_validate_lines(\n        os.path.join(curr_path, "files/test_repos_good.txt"),\n        r"[A-Za-z0-9-_.]+\/[A-Za-z0-9-_.]+",\n    )\n\n    assert "someorg/somerepository" in res\n    assert "some_org/some-repo" in res\n\ndef test_repos_file_bad(capfd):\n    """Test that the good file is validated without errors."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n\n    with pytest.raises(SystemExit):\n        cli.cli(\n            ["enumerate", "-R", os.path.join(curr_path, "files/test_repos_bad.txt")]\n        )\n    out, err = capfd.readouterr()\n\n    assert "invalid repository name!" in err\n\ndef test_valid_dir():\n    """Test that the directory validation function works."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n    mock_parser = mock.MagicMock()\n\n    res = is_valid_directory(mock_parser, os.path.join(curr_path, "files/"))\n\n    assert res == os.path.join(curr_path, "files/")\n\ndef test_invalid_dir(capfd):\n    """Test that the directory validation function works."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n    mock_parser = mock.MagicMock()\n\n    res = is_valid_directory(mock_parser, os.path.join(curr_path, "invaliddir/"))\n\n    assert res is None\n\n    mock_parser.error.assert_called_with(\n        "The directory {} does not exist!".format(\n            os.path.join(curr_path, "invaliddir/")\n        )\n    )\n\n@mock.patch("gatox.attack.runner.webshell.WebShell.runner_on_runner")\ndef test_attack_pr(mock_attack):\n    """Test attack command using the pr method."""\n    cli.cli(\n        [\n            "attack",\n            "-t",\n            "test",\n            "-pr",\n            "--target-os",\n            "linux",\n            "--target-arch",\n            "x64",\n        ]\n    )\n    mock_attack.assert_called_once()\n\n@mock.patch("gatox.attack.runner.webshell.WebShell.runner_on_runner")\ndef test_attack_pr_bados(mock_attack, capfd):\n    """Test attack command using the pr method."""\n    with pytest.raises(SystemExit):\n        cli.cli(\n            [\n                "attack",\n                "-t",\n                "test",\n                "-pr",\n                "--target-os",\n                "solaris",\n                "--target-arch",\n                "x64",\n            ]\n        )\n    out, err = capfd.readouterr()\n    assert "invalid choice: 'solaris'" in err\n\n@mock.patch("gatox.attack.attack.Attacker.push_workflow_attack")\ndef test_attack_workflow(mock_attack):\n    """Test attack command using the workflow method."""\n    cli.cli(["attack", "-t", "test", "-w"])\n    mock_attack.assert_called_once()\n\n@mock.patch("os.path.isdir")\ndef test_enum_bad_args1(mock_dircheck, capfd):\n    """Test enum command with invalid output location."""\n    mock_dircheck.return_value = False\n\n    with pytest.raises(SystemExit):\n        cli.cli(["enum", "-o", "invalid"])\n\n    out, err = capfd.readouterr()\n    assert "--output-yaml/-o: The directory: invalid does not exist!" in err\n\ndef test_enum_bad_args2(capfd):\n    """Test enum command without a type selection."""\n    with pytest.raises(SystemExit):\n        cli.cli(["enum"])\n\n    out, err = capfd.readouterr()\n    assert "type was specified" in err\n\ndef test_enum_bad_args3(capfd):\n    """Test enum command with multiple type selections."""\n    with pytest.raises(SystemExit):\n        cli.cli(["enum", "-t", "test", "-r", "testorg/test2"])\n\n    out, err = capfd.readouterr()\n    assert "select one enumeration" in err\n\n@mock.patch("gatox.enumerate.enumerate.Enumerator.self_enumeration")\ndef test_enum_self(mock_enumerate):\n    """Test enum command using the self enumeration."""\n    mock_enumerate.return_value = (["org1"], ["org2"])\n\n    cli.cli(["enum", "-s"])\n    mock_enumerate.assert_called_once()\n\n@mock.patch("gatox.cli.cli.Enumerator")\ndef test_enum_org(mock_enumerator):\n    """Test enum command using the organization enumeration."""\n    mock_instance = mock_enumerator.return_value\n    mock_api = mock.MagicMock()\n\n    mock_api.check_user.return_value = {\n        "user": "testUser",\n        "scopes": ["repo", "workflow"],\n    }\n    mock_api.get_user_type.return_value = "Organization"\n    mock_instance.api = mock_api\n\n    cli.cli(["enum", "-t", "test"])\n\n    mock_instance.enumerate_organization.assert_called_once()\n\n@mock.patch("gatox.cli.cli.Enumerator")\ndef test_enum_user(mock_enumerator):\n    """Test enum command using the user enumeration."""\n    mock_instance = mock_enumerator.return_value\n    mock_api = mock.MagicMock()\n\n    mock_api.check_user.return_value = {\n        "user": "testUser",\n        "scopes": ["repo", "workflow"],\n    }\n    mock_api.get_user_type.return_value = "User"\n    mock_instance.api = mock_api\n\n    cli.cli(["enum", "-t", "testUser"])\n\n    mock_instance.enumerate_user.assert_called_once()\n\n@mock.patch("gatox.enumerate.enumerate.Enumerator.enumerate_repos")\n@mock.patch("gatox.util.arg_utils.read_file_and_validate_lines")\ndef test_enum_repos(mock_read, mock_enumerate):\n    """Test enum command using the repo list."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n    mock_read.return_value = ["repos"]\n\n    cli.cli(["enum", "-R", os.path.join(curr_path, "files/test_repos_good.txt")])\n    mock_read.assert_called_once()\n    mock_enumerate.assert_called_once()\n\n@mock.patch("gatox.enumerate.enumerate.Enumerator.enumerate_repos")\ndef test_enum_repo(mock_enumerate):\n    """Test enum command using the single repo enumeration."""\n    cli.cli(["enum", "-r", "testorg/testrepo"])\n    mock_enumerate.assert_called_once()\n\n@mock.patch("gatox.search.search.Searcher.use_search_api")\ndef test_search(mock_search):\n    """Test search command."""\n    cli.cli(["search", "-t", "test"])\n    mock_search.assert_called_once()\n\ndef test_long_repo_name(capfd):\n    """Test enum command using name that is too long."""\n    repo_name = "Org/" + "A" * 80\n\n    with pytest.raises(SystemExit):\n        cli.cli(["enum", "-r", repo_name])\n\n    out, err = capfd.readouterr()\n\n    assert "The maximum length is 79 characters!" in err\n\ndef test_invalid_repo_name(capfd):\n    """Test enum command using invalid full repo name."""\n    with pytest.raises(SystemExit):\n        cli.cli(["enum", "-r", "RepoWithoutOrg"])\n\n    out, err = capfd.readouterr()\n\n    assert (\n        "argument --repository/-r: The argument is not in the valid format!" in err\n    )\n\n@mock.patch("gatox.util.arg_utils.os.access")\ndef test_unreadable_file(mock_access, capfd):\n    """Test enum command unreadable file."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n\n    mock_access.return_value = False\n\n    with pytest.raises(SystemExit):\n        cli.cli(["enum", "-R", os.path.join(curr_path, "files/bad_dir/bad_file")])\n\n    out, err = capfd.readouterr()\n\n    assert " is not readable" in err\n\n@mock.patch("gatox.util.arg_utils.os.access")\ndef test_unwritable_dir(mock_access, capfd):\n    """Test enum command unwritable dir."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n\n    mock_access.return_value = False\n\n    with pytest.raises(SystemExit):\n        cli.cli(\n            [\n                "enum",\n                "-r",\n                "testOrg/testRepo",\n                "-o",\n                os.path.join(curr_path, "files/bad_dir"),\n            ]\n        )\n\n    out, err = capfd.readouterr()\n\n    assert " is not writeable" in err\n\n@mock.patch("gatox.cli.cli.Enumerator")\ndef test_enum_validate(mock_enumerator, capfd):\n    """Test enum command with validation only."""\n    os.environ["GH_TOKEN"] = "ghp_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"\n    mock_instance = mock_enumerator.return_value.api = mock.MagicMock()\n    mock_instance.check_user.return_value = {\n        "user": "testUser",\n        "scopes": ["repo", "workflow"],\n    }\n    mock_instance.is_app_token.return_value = False\n    mock_instance.check_organizations.return_value = []\n\n    cli.cli(["enum", "-t", "test", "--validate"])\n    out, err = capfd.readouterr()\n    assert "authenticated user is: testUser" in out\n    assert "The user testUser belongs to 0 organizations!" in out\n