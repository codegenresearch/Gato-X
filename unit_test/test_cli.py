import os\nimport pathlib\nimport pytest\nfrom unittest import mock\n\n# Standard library imports\nimport os\nimport pathlib\n\n# Third-party imports\nimport pytest\nfrom unittest import mock\n\n# Local application imports\nfrom gatox.cli import cli\nfrom gatox.util.arg_utils import read_file_and_validate_lines, is_valid_directory\nfrom gatox.enumerate.enumerate import repo_wrappers\n\nrepo_wrappers()\n\n@pytest.fixture(autouse=True)\ndef mock_settings_env_vars():\n    with mock.patch.dict(os.environ, {\n        "GH_TOKEN": "ghp_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"\n    }):\n        yield\n\ndef test_cli_no_gh_token(capfd):\n    """Test case where no GH Token is provided."""\n    del os.environ["GH_TOKEN"]\n    with pytest.raises(OSError):\n        cli.cli(["enumerate", "-t", "test"])\n    out, err = capfd.readouterr()\n    assert "Please enter" in out\n\ndef test_cli_fine_grained_pat(capfd):\n    """Test case where an unsupported PAT is provided."""\n    os.environ["GH_TOKEN"] = "github_pat_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"\n    with pytest.raises(SystemExit):\n        cli.cli(["enumerate", "-t", "test"])\n    out, err = capfd.readouterr()\n    assert "not supported" in err\n\ndef test_cli_s2s_token(capfd):\n    """Test case where a service-to-service token is provided."""\n    os.environ["GH_TOKEN"] = "ghs_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"\n    with pytest.raises(SystemExit):\n        cli.cli(["enumerate", "-t", "test"])\n    out, err = capfd.readouterr()\n    assert "not support App tokens without machine flag" in err\n\ndef test_cli_s2s_token_no_machine(capfd):\n    """Test case where a service-to-service token is provided without machine flag."""\n    os.environ["GH_TOKEN"] = "ghs_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"\n    with pytest.raises(SystemExit):\n        cli.cli(["enumerate", "-r", "testOrg/testRepo"])\n    out, err = capfd.readouterr()\n    assert "not support App tokens without machine flag" in err\n\ndef test_cli_s2s_token_machine(capfd):\n    """Test case where a service-to-service token is provided with machine flag."""\n    os.environ["GH_TOKEN"] = "ghs_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"\n    cli.cli(["enumerate", "-r", "testOrg/testRepo", "--machine"])\n    out, err = capfd.readouterr()\n    assert "Allowing the use of a GitHub App token for single repo enumeration" in out\n\ndef test_cli_u2s_token(capfd):\n    """Test case where a user-to-server token is provided."""\n    os.environ["GH_TOKEN"] = "ghu_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"\n    with pytest.raises(SystemExit):\n        cli.cli(["enumerate", "-t", "test"])\n    out, err = capfd.readouterr()\n    assert "Provided GitHub PAT is malformed or unsupported" in err\n\n@mock.patch("gatox.cli.cli.Enumerator")\ndef test_cli_oauth_token(mock_enumerator, capfd):\n    """Test case where a GitHub OAuth token is provided."""\n    os.environ["GH_TOKEN"] = "gho_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"\n    mock_instance = mock_enumerator.return_value\n    mock_api = mock.MagicMock()\n    mock_api.check_user.return_value = {\n        "user": "testUser",\n        "scopes": ["repo", "workflow"],\n    }\n    mock_api.get_user_type.return_value = "Organization"\n    mock_instance.api = mock_api\n\n    cli.cli(["enumerate", "-t", "test"])\n    out, err = capfd.readouterr()\n\n    mock_instance.enumerate_organization.assert_called_once()\n\n@mock.patch("gatox.cli.cli.Enumerator")\ndef test_cli_old_token(mock_enumerator, capfd):\n    """Test case where an old, but still potentially valid GitHub token is provided."""\n    os.environ["GH_TOKEN"] = "43255147468edf32a206441ad296ce648f44ee32"\n    mock_instance = mock_enumerator.return_value\n    mock_api = mock.MagicMock()\n    mock_api.check_user.return_value = {\n        "user": "testUser",\n        "scopes": ["repo", "workflow"],\n    }\n    mock_api.get_user_type.return_value = "Organization"\n    mock_instance.api = mock_api\n\n    cli.cli(["enumerate", "-t", "test"])\n    out, err = capfd.readouterr()\n\n    mock_instance.enumerate_organization.assert_called_once()\n\ndef test_cli_invalid_pat(capfd):\n    """Test case where a clearly invalid PAT is provided."""\n    os.environ["GH_TOKEN"] = "invalid"\n    with pytest.raises(SystemExit):\n        cli.cli(["enumerate", "-t", "test"])\n    out, err = capfd.readouterr()\n    assert "malformed" in err\n\ndef test_cli_double_proxy(capfd):\n    """Test case where conflicting proxies are provided."""\n    with pytest.raises(SystemExit):\n        cli.cli(["-sp", "socks", "-p", "http", "enumerate", "-t", "test"])\n    out, err = capfd.readouterr()\n    assert "proxy at the same time" in err\n\ndef test_attack_missing_method(capfd):\n    """Test attack command without the attack method."""\n    with pytest.raises(SystemExit):\n        cli.cli(["attack", "-t", "test"])\n    out, err = capfd.readouterr()\n    assert "must select one" in err\n\ndef test_attack_conflicting_params(capfd):\n    """Test attack command with conflicting params."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n    with pytest.raises(SystemExit):\n        cli.cli([\n            "attack",\n            "-t",\n            "test",\n            "-pr",\n            "-f",\n            os.path.join(curr_path, "files/main.yaml"),\n            "-n",\n            "invalid",\n        ])\n    out, err = capfd.readouterr()\n    assert "cannot be used with a custom" in err\n\ndef test_attack_invalid_file_path(capfd):\n    """Test attack command with an invalid path."""\n    with pytest.raises(SystemExit):\n        cli.cli(["attack", "-t", "test", "-pr", "-f", "path"])\n    out, err = capfd.readouterr()\n    assert "argument --custom-file/-f: The file: path does not exist!" in err\n\ndef test_repos_file_valid():\n    """Test that the good file is validated without errors."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n    res = read_file_and_validate_lines(\n        os.path.join(curr_path, "files/test_repos_good.txt"),\n        r"[A-Za-z0-9-_.]+/[A-Za-z0-9-_.]+",\n    )\n    assert "someorg/somerepository" in res\n    assert "some_org/some-repo" in res\n\ndef test_repos_file_invalid(capfd):\n    """Test that the bad file is validated with errors."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n    with pytest.raises(SystemExit):\n        cli.cli([\n            "enumerate",\n            "-R",\n            os.path.join(curr_path, "files/test_repos_bad.txt"),\n        ])\n    out, err = capfd.readouterr()\n    assert "invalid repository name!" in err\n\ndef test_valid_directory():\n    """Test that the directory validation function works."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n    mock_parser = mock.MagicMock()\n    res = is_valid_directory(mock_parser, os.path.join(curr_path, "files/"))\n    assert res == os.path.join(curr_path, "files/")\n\ndef test_invalid_directory(capfd):\n    """Test that the directory validation function works with an invalid directory."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n    mock_parser = mock.MagicMock()\n    res = is_valid_directory(mock_parser, os.path.join(curr_path, "invaliddir/"))\n    assert res is None\n    mock_parser.error.assert_called_with(\n        "The directory {} does not exist!".format(os.path.join(curr_path, "invaliddir/"))\n    )\n\n@mock.patch("gatox.attack.runner.webshell.WebShell.runner_on_runner")\ndef test_attack_pr_method(mock_attack):\n    """Test attack command using the pr method."""\n    cli.cli([\n        "attack",\n        "-t",\n        "test",\n        "-pr",\n        "--target-os",\n        "linux",\n        "--target-arch",\n        "x64",\n    ])\n    mock_attack.assert_called_once()\n\n@mock.patch("gatox.attack.runner.webshell.WebShell.runner_on_runner")\ndef test_attack_pr_invalid_os(mock_attack, capfd):\n    """Test attack command using the pr method with an invalid OS."""\n    with pytest.raises(SystemExit):\n        cli.cli([\n            "attack",\n            "-t",\n            "test",\n            "-pr",\n            "--target-os",\n            "solaris",\n            "--target-arch",\n            "x64",\n        ])\n    out, err = capfd.readouterr()\n    assert "invalid choice: 'solaris'" in err\n\n@mock.patch("gatox.attack.attack.Attacker.push_workflow_attack")\ndef test_attack_workflow_method(mock_attack):\n    """Test attack command using the workflow method."""\n    cli.cli(["attack", "-t", "test", "-w"])\n    mock_attack.assert_called_once()\n\n@mock.patch("os.path.isdir")\ndef test_enum_invalid_output_location(mock_dircheck, capfd):\n    """Test enum command with invalid output location."""\n    mock_dircheck.return_value = False\n    with pytest.raises(SystemExit):\n        cli.cli(["enum", "-o", "invalid"])\n    out, err = capfd.readouterr()\n    assert "--output-yaml/-o: The directory: invalid does not exist!" in err\n\ndef test_enum_no_type_selection(capfd):\n    """Test enum command without a type selection."""\n    with pytest.raises(SystemExit):\n        cli.cli(["enum"])\n    out, err = capfd.readouterr()\n    assert "type was specified" in err\n\ndef test_enum_multiple_type_selections(capfd):\n    """Test enum command with multiple type selections."""\n    with pytest.raises(SystemExit):\n        cli.cli(["enum", "-t", "test", "-r", "testorg/test2"])\n    out, err = capfd.readouterr()\n    assert "select one enumeration" in err\n\n@mock.patch("gatox.enumerate.enumerate.Enumerator.self_enumeration")\ndef test_enum_self_enumeration(mock_enumerate):\n    """Test enum command using self enumeration."""\n    mock_enumerate.return_value = (["org1"], ["org2"])\n    cli.cli(["enum", "-s"])\n    mock_enumerate.assert_called_once()\n\n@mock.patch("gatox.cli.cli.Enumerator")\ndef test_enum_organization_enumeration(mock_enumerator):\n    """Test enum command using organization enumeration."""\n    mock_instance = mock_enumerator.return_value\n    mock_api = mock.MagicMock()\n    mock_api.check_user.return_value = {\n        "user": "testUser",\n        "scopes": ["repo", "workflow"],\n    }\n    mock_api.get_user_type.return_value = "Organization"\n    mock_instance.api = mock_api\n    cli.cli(["enum", "-t", "test"])\n    mock_instance.enumerate_organization.assert_called_once()\n\n@mock.patch("gatox.cli.cli.Enumerator")\ndef test_enum_user_enumeration(mock_enumerator):\n    """Test enum command using user enumeration."""\n    mock_instance = mock_enumerator.return_value\n    mock_api = mock.MagicMock()\n    mock_api.check_user.return_value = {\n        "user": "testUser",\n        "scopes": ["repo", "workflow"],\n    }\n    mock_api.get_user_type.return_value = "User"\n    mock_instance.api = mock_api\n    cli.cli(["enum", "-t", "testUser"])\n    mock_instance.enumerate_user.assert_called_once()\n\n@mock.patch("gatox.enumerate.enumerate.Enumerator.enumerate_repos")\n@mock.patch("gatox.util.arg_utils.read_file_and_validate_lines")\ndef test_enum_repo_list(mock_read, mock_enumerate):\n    """Test enum command using the repo list."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n    mock_read.return_value = ["repos"]\n    cli.cli(["enum", "-R", os.path.join(curr_path, "files/test_repos_good.txt")])\n    mock_read.assert_called_once()\n    mock_enumerate.assert_called_once()\n\n@mock.patch("gatox.enumerate.enumerate.Enumerator.enumerate_repos")\ndef test_enum_single_repo(mock_enumerate):\n    """Test enum command using repository enumeration."""\n    cli.cli(["enum", "-r", "testorg/testrepo"])\n    mock_enumerate.assert_called_once()\n\n@mock.patch("gatox.search.search.Searcher.use_search_api")\ndef test_search_command(mock_search):\n    """Test search command."""\n    cli.cli(["search", "-t", "test"])\n    mock_search.assert_called_once()\n\ndef test_enum_long_repo_name(capfd):\n    """Test enum command using a repository name that is too long."""\n    repo_name = "Org/" + "A" * 80\n    with pytest.raises(SystemExit):\n        cli.cli(["enum", "-r", repo_name])\n    out, err = capfd.readouterr()\n    assert "The maximum length is 79 characters!" in err\n\ndef test_enum_invalid_repo_name(capfd):\n    """Test enum command using an invalid full repository name."""\n    with pytest.raises(SystemExit):\n        cli.cli(["enum", "-r", "RepoWithoutOrg"])\n    out, err = capfd.readouterr()\n    assert (\n        "argument --repository/-r: The argument is not in the valid format!" in err\n    )\n\n@mock.patch("gatox.util.arg_utils.os.access")\ndef test_enum_unreadable_file(mock_access, capfd):\n    """Test enum command with an unreadable file."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n    mock_access.return_value = False\n    with pytest.raises(SystemExit):\n        cli.cli(["enum", "-R", os.path.join(curr_path, "files/bad_dir/bad_file")])\n    out, err = capfd.readouterr()\n    assert " is not readable" in err\n\n@mock.patch("gatox.util.arg_utils.os.access")\ndef test_enum_unwritable_directory(mock_access, capfd):\n    """Test enum command with an unwritable directory."""\n    curr_path = pathlib.Path(__file__).parent.resolve()\n    mock_access.return_value = False\n    with pytest.raises(SystemExit):\n        cli.cli([\n            "enum",\n            "-r",\n            "testOrg/testRepo",\n            "-o",\n            os.path.join(curr_path, "files/bad_dir"),\n        ])\n    out, err = capfd.readouterr()\n    assert " is not writeable" in err\n\n@mock.patch("gatox.cli.cli.Enumerator")\ndef test_enum_output_json(mock_enumerator, capfd):\n    """Test enum command with JSON output."""\n    mock_instance = mock_enumerator.return_value\n    mock_api = mock.MagicMock()\n    mock_api.check_user.return_value = {\n        "user": "testUser",\n        "scopes": ["repo", "workflow"],\n    }\n    mock_api.get_user_type.return_value = "Organization"\n    mock_instance.api = mock_api\n    cli.cli(["enum", "-t", "test", "--output-json", "output.json"])\n    mock_instance.enumerate_organization.assert_called_once()\n    out, err = capfd.readouterr()\n    assert "Saving enumeration output to JSON file: output.json" in out\n