import os\nimport pathlib\nimport pytest\nimport json\nfrom unittest.mock import patch, MagicMock\nfrom gatox.models.repository import Repository\nfrom gatox.enumerate.enumerate import Enumerator\nfrom gatox.cli.output import Output\nfrom unit_test.utils import escape_ansi\n\nTEST_REPO_DATA = None\nTEST_WORKFLOW_YML = None\nTEST_ORG_DATA = None\nBASE_MOCK_RUNNER = [\n    {\n        'machine_name': 'unittest1',\n        'runner_name': 'much_unit_such_test',\n        'runner_type': 'organization',\n        'non_ephemeral': False,\n        'token_permissions': {'Actions': 'write'},\n        'runner_group': 'Default',\n        'requested_labels': ['self-hosted', 'Linux', 'X64'],\n    }\n]\n\n@pytest.fixture(scope='session', autouse=True)\ndef load_test_files():\n    global TEST_REPO_DATA\n    global TEST_ORG_DATA\n    global TEST_WORKFLOW_YML\n    curr_path = pathlib.Path(__file__).parent.resolve()\n    test_repo_path = os.path.join(curr_path, 'files/example_repo.json')\n    test_org_path = os.path.join(curr_path, 'files/example_org.json')\n    test_wf_path = os.path.join(curr_path, 'files/main.yaml')\n\n    with open(test_repo_path, 'r') as repo_data:\n        TEST_REPO_DATA = json.load(repo_data)\n\n    with open(test_org_path, 'r') as org_data:\n        TEST_ORG_DATA = json.load(org_data)\n\n    with open(test_wf_path, 'r') as wf_data:\n        TEST_WORKFLOW_YML = wf_data.read()\n\n\n@patch('gatox.enumerate.enumerate.Api')\ndef test_init(mock_api):\n    '''Test constructor for enumerator.'''\n    gh_enumeration_runner = Enumerator(\n        'ghp_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA',\n        socks_proxy=None,\n        http_proxy='localhost:8080',\n        output_yaml=True,\n        skip_log=False,\n    )\n    assert gh_enumeration_runner.http_proxy == 'localhost:8080'\n\n\n@patch('gatox.enumerate.enumerate.Api')\ndef test_self_enumerate(mock_api, capsys):\n    '''Test self enumeration method.'''\n    mock_api.return_value.is_app_token.return_value = False\n    mock_api.return_value.check_user.return_value = {\n        'user': 'testUser',\n        'scopes': ['repo', 'workflow'],\n    }\n    mock_api.return_value.check_organizations.return_value = []\n\n    gh_enumeration_runner = Enumerator(\n        'ghp_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA',\n        socks_proxy=None,\n        http_proxy='localhost:8080',\n        output_yaml=True,\n        skip_log=False,\n    )\n\n    gh_enumeration_runner.self_enumeration()\n\n    captured = capsys.readouterr()\n    print_output = captured.out\n    assert 'The user testUser belongs to 0 organizations!' in escape_ansi(print_output)\n\n\n@patch('gatox.enumerate.enumerate.Api')\ndef test_enumerate_repo_admin(mock_api, capsys):\n    '''Test repository enumeration with admin permissions.'''\n    gh_enumeration_runner = Enumerator(\n        'ghp_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA',\n        socks_proxy=None,\n        http_proxy='localhost:8080',\n        output_yaml=True,\n        skip_log=False,\n    )\n\n    mock_api.return_value.is_app_token.return_value = False\n    mock_api.return_value.check_user.return_value = {\n        'user': 'testUser',\n        'scopes': ['repo', 'workflow'],\n    }\n    mock_api.return_value.retrieve_run_logs.return_value = BASE_MOCK_RUNNER\n\n    repo_data = json.loads(json.dumps(TEST_REPO_DATA))\n    repo_data['permissions']['admin'] = True\n    mock_api.return_value.get_repository.return_value = repo_data\n\n    gh_enumeration_runner.enumerate_repo_only(repo_data['full_name'])\n\n    captured = capsys.readouterr()\n    print_output = captured.out\n    assert 'The user is an administrator on the' in escape_ansi(print_output)\n\n\n@patch('gatox.enumerate.enumerate.Api')\ndef test_enumerate_repo_admin_no_wf(mock_api, capsys):\n    '''Test repository enumeration with admin permissions but no workflow scope.'''\n    gh_enumeration_runner = Enumerator(\n        'ghp_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA',\n        socks_proxy=None,\n        http_proxy='localhost:8080',\n        output_yaml=True,\n        skip_log=False,\n    )\n\n    mock_api.return_value.is_app_token.return_value = False\n    mock_api.return_value.check_user.return_value = {\n        'user': 'testUser',\n        'scopes': ['repo'],\n    }\n    mock_api.return_value.retrieve_run_logs.return_value = BASE_MOCK_RUNNER\n\n    repo_data = json.loads(json.dumps(TEST_REPO_DATA))\n    repo_data['permissions']['admin'] = True\n    mock_api.return_value.get_repository.return_value = repo_data\n\n    gh_enumeration_runner.enumerate_repo_only(repo_data['full_name'])\n\n    captured = capsys.readouterr()\n    print_output = captured.out\n    assert ' is public this token can be used to approve a' in escape_ansi(print_output)\n\n\n@patch('gatox.enumerate.enumerate.Api')\ndef test_enumerate_repo_no_wf_no_admin(mock_api, capsys):\n    '''Test repository enumeration with no workflow scope and no admin permissions.'''\n    gh_enumeration_runner = Enumerator(\n        'ghp_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA',\n        socks_proxy=None,\n        http_proxy='localhost:8080',\n        output_yaml=True,\n        skip_log=False,\n    )\n\n    mock_api.return_value.is_app_token.return_value = False\n    mock_api.return_value.check_user.return_value = {\n        'user': 'testUser',\n        'scopes': ['repo'],\n    }\n    mock_api.return_value.retrieve_run_logs.return_value = BASE_MOCK_RUNNER\n\n    repo_data = json.loads(json.dumps(TEST_REPO_DATA))\n    repo_data['permissions']['admin'] = False\n    mock_api.return_value.get_repository.return_value = repo_data\n\n    gh_enumeration_runner.enumerate_repo_only(repo_data['full_name'])\n\n    captured = capsys.readouterr()\n    print_output = captured.out\n    assert ' scope, which means an existing workflow trigger must' in escape_ansi(print_output)\n\n\n@patch('gatox.enumerate.enumerate.Api')\ndef test_enumerate_repo_no_wf_maintain(mock_api, capsys):\n    '''Test repository enumeration with maintain permissions but no workflow scope.'''\n    gh_enumeration_runner = Enumerator(\n        'ghp_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA',\n        socks_proxy=None,\n        http_proxy='localhost:8080',\n        output_yaml=True,\n        skip_log=False,\n    )\n\n    mock_api.return_value.is_app_token.return_value = False\n    mock_api.return_value.check_user.return_value = {\n        'user': 'testUser',\n        'scopes': ['repo', 'workflow'],\n    }\n    mock_api.return_value.retrieve_run_logs.return_value = BASE_MOCK_RUNNER\n\n    repo_data = json.loads(json.dumps(TEST_REPO_DATA))\n    repo_data['permissions']['maintain'] = True\n    mock_api.return_value.get_repository.return_value = repo_data\n\n    gh_enumeration_runner.enumerate_repo_only(repo_data['full_name'])\n    captured = capsys.readouterr()\n    print_output = captured.out\n    assert ' The user is a maintainer on the' in escape_ansi(print_output)\n\n\n@patch('gatox.enumerate.enumerate.Api')\ndef test_enumerate_repo_only(mock_api, capsys):\n    '''Test repository enumeration with workflow scope.'''\n    repo_data = json.loads(json.dumps(TEST_REPO_DATA))\n    gh_enumeration_runner = Enumerator(\n        'ghp_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA',\n        socks_proxy=None,\n        http_proxy='localhost:8080',\n        output_yaml=True,\n        skip_log=False,\n    )\n\n    mock_api.return_value.is_app_token.return_value = False\n    mock_api.return_value.check_user.return_value = {\n        'user': 'testUser',\n        'scopes': ['repo', 'workflow'],\n    }\n    mock_api.return_value.retrieve_run_logs.return_value = BASE_MOCK_RUNNER\n    mock_api.return_value.get_repository.return_value = repo_data\n\n    gh_enumeration_runner.enumerate_repo_only(repo_data['full_name'])\n\n    captured = capsys.readouterr()\n    print_output = captured.out\n    assert 'Runner Name: much_unit_such_test' in escape_ansi(print_output)\n    assert 'Machine Name: unittest1' in escape_ansi(print_output)\n    assert 'Labels: self-hosted, Linux, X64' in escape_ansi(print_output)\n\n\n@patch('gatox.enumerate.enumerate.Api')\ndef test_enum_validate(mock_api, capfd):\n    '''Test validation method.'''\n    mock_api.return_value.check_user.return_value = {\n        'user': 'testUser',\n        'scopes': ['repo', 'workflow'],\n    }\n    mock_api.return_value.is_app_token.return_value = False\n    mock_api.return_value.check_organizations.return_value = []\n\n    gh_enumeration_runner = Enumerator(\n        'ghp_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA',\n        socks_proxy=None,\n        http_proxy=None,\n        output_yaml=False,\n        skip_log=True,\n    )\n\n    gh_enumeration_runner.validate_only()\n    out, err = capfd.readouterr()\n    assert 'authenticated user is: testUser' in escape_ansi(out)\n    assert 'The user testUser belongs to 0 organizations!' in escape_ansi(out)\n\n\n@patch('gatox.enumerate.ingest.ingest.time')\n@patch('gatox.enumerate.enumerate.Api')\ndef test_enum_repo(mock_api, mock_time, capfd):\n    '''Test repository enumeration.'''\n    mock_api.return_value.check_user.return_value = {\n        'user': 'testUser',\n        'scopes': ['repo', 'workflow'],\n    }\n    mock_api.return_value.is_app_token.return_value = False\n    mock_api.return_value.get_repository.return_value = TEST_REPO_DATA\n\n    gh_enumeration_runner = Enumerator(\n        'ghp_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA',\n        socks_proxy=None,\n        http_proxy=None,\n        output_yaml=False,\n        skip_log=True,\n    )\n\n    gh_enumeration_runner.enumerate_repo_only('octocat/Hello-World')\n    out, err = capfd.readouterr()\n    assert 'Enumerating: octocat/Hello-World' in escape_ansi(out)\n    mock_api.return_value.get_repository.assert_called_once_with('octocat/Hello-World')\n\n\n@patch('gatox.enumerate.ingest.ingest.time')\n@patch('gatox.enumerate.enumerate.Api')\ndef test_enum_org(mock_api, mock_time, capfd):\n    '''Test organization enumeration.'''\n    mock_api.return_value.check_user.return_value = {\n        'user': 'testUser',\n        'scopes': ['repo', 'workflow', 'admin:org'],\n    }\n    mock_api.return_value.is_app_token.return_value = False\n    mock_api.return_value.get_repository.return_value = TEST_REPO_DATA\n    mock_api.return_value.get_organization_details.return_value = TEST_ORG_DATA\n\n    mock_api.return_value.get_org_secrets.return_value = [\n        {\n            'name': 'DEPLOY_TOKEN',\n            'created_at': '2019-08-10T14:59:22Z',\n            'updated_at': '2020-01-10T14:59:22Z',\n            'visibility': 'all',\n        },\n        {\n            'name': 'GH_TOKEN',\n            'created_at': '2019-08-10T14:59:22Z',\n            'updated_at': '2020-01-10T14:59:22Z',\n            'visibility': 'selected',\n            'selected_repositories_url': 'https://api.github.com/orgs/testOrg/actions/secrets/GH_TOKEN/repositories',\n        },\n    ]\n\n    mock_api.return_value.check_org_runners.return_value = {\n        'total_count': 1,\n        'runners': [\n            {\n                'id': 21,\n                'name': 'ghrunner-test',\n                'os': 'Linux',\n                'status': 'online',\n                'busy': False,\n                'labels': [\n                    {'id': 1, 'name': 'self-hosted', 'type': 'read-only'},\n                    {'id': 2, 'name': 'Linux', 'type': 'read-only'},\n                    {'id': 3, 'name': 'X64', 'type': 'read-only'},\n                ],\n            }\n        ],\n    }\n\n    mock_api.return_value.check_org_repos.side_effect = [[TEST_REPO_DATA], [], []]\n\n    mock_api.return_value.get_secrets.return_value = [\n        {\n            'name': 'TEST_SECRET',\n            'created_at': '2019-08-10T14:59:22Z',\n            'updated_at': '2020-01-10T14:59:22Z',\n        }\n    ]\n\n    mock_api.return_value.get_repo_org_secrets.return_value = []\n\n    gh_enumeration_runner = Enumerator(\n        'ghp_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA',\n        socks_proxy=None,\n        http_proxy=None,\n        output_yaml=False,\n        skip_log=True,\n    )\n\n    gh_enumeration_runner.enumerate_organization('github')\n\n    out, err = capfd.readouterr()\n    escaped_output = escape_ansi(out)\n    assert ('The repository can access 1 secret(s) and the token can use a workflow to read them!' in escaped_output)\n    assert 'TEST_SECRET' in escaped_output\n    assert 'ghrunner-test' in escaped_output\n\n\n@patch('gatox.enumerate.enumerate.Api')\ndef test_enum_repo_runner(mock_api, capfd):\n    '''Test repository runner enumeration.'''\n    mock_api.return_value.check_user.return_value = {\n        'user': 'testUser',\n        'scopes': ['repo', 'workflow'],\n    }\n    mock_api.return_value.is_app_token.return_value = False\n    mock_api.return_value.get_repo_runners.return_value = [\n        {\n            'id': 2,\n            'name': '17e749a1b008',\n            'os': 'Linux',\n            'status': 'offline',\n            'busy': False,\n            'labels': [\n                {'id': 1, 'name': 'self-hosted', 'type': 'read-only'},\n                {'id': 2, 'name': 'Linux', 'type': 'read-only'},\n                {'id': 3, 'name': 'X64', 'type': 'read-only'},\n            ],\n        }\n    ]\n\n    test_repodata = TEST_REPO_DATA.copy()\n    test_repodata['permissions']['admin'] = True\n    mock_api.return_value.get_repository.return_value = test_repodata\n\n    gh_enumeration_runner = Enumerator(\n        'ghp_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA',\n        socks_proxy=None,\n        http_proxy=None,\n        output_yaml=False,\n        skip_log=True,\n    )\n\n    gh_enumeration_runner.enumerate_repo_only('octocat/Hello-World')\n    out, err = capfd.readouterr()\n    escaped_output = escape_ansi(out)\n    assert 'The repository has 1 repo-level self-hosted runners!' in escaped_output\n    assert '[!] The user is an administrator on the repository!' in escaped_output\n    assert ('The runner has the following labels: self-hosted, Linux, X64!' in escaped_output)\n\n\n@patch('gatox.enumerate.ingest.ingest.time')\n@patch('gatox.enumerate.enumerate.Api')\ndef test_enum_repos(mock_api, mock_time, capfd):\n    '''Test enumeration of multiple repositories.'''\n    mock_api.return_value.check_user.return_value = {\n        'user': 'testUser',\n        'scopes': ['repo', 'workflow'],\n    }\n    mock_api.return_value.is_app_token.return_value = False\n    mock_api.return_value.get_repository.return_value = TEST_REPO_DATA\n\n    gh_enumeration_runner = Enumerator(\n        'ghp_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA',\n        socks_proxy=None,\n        http_proxy=None,\n        output_yaml=False,\n        skip_log=True,\n    )\n\n    gh_enumeration_runner.enumerate_repos(['octocat/Hello-World'])\n    out, _ = capfd.readouterr()\n    assert 'Enumerating: octocat/Hello-World' in escape_ansi(out)\n    mock_api.return_value.get_repository.assert_called_once_with('octocat/Hello-World')\n\n\n@patch('gatox.enumerate.enumerate.Api')\ndef test_enum_repos_empty(mock_api, capfd):\n    '''Test enumeration with an empty list of repositories.'''\n    mock_api.return_value.check_user.return_value = {\n        'user': 'testUser',\n        'scopes': ['repo', 'workflow'],\n    }\n    mock_api.return_value.is_app_token.return_value = False\n    mock_api.return_value.get_repository.return_value = TEST_REPO_DATA\n\n    gh_enumeration_runner = Enumerator(\n        'ghp_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA',\n        socks_proxy=None,\n        http_proxy=None,\n        output_yaml=False,\n        skip_log=True,\n    )\n\n    gh_enumeration_runner.enumerate_repos([])\n    out, _ = capfd.readouterr()\n    assert 'The list of repositories was empty!' in escape_ansi(out)\n    mock_api.return_value.get_repository.assert_not_called()\n\n\n@patch('gatox.enumerate.enumerate.Api')\ndef test_bad_token(mock_api):\n    '''Test enumeration with a bad token.'''\n    gh_enumeration_runner = Enumerator(\n        'ghp_BADTOKEN',\n        socks_proxy=None,\n        http_proxy=None,\n        output_yaml=False,\n        skip_log=True,\n    )\n\n    mock_api.return_value.is_app_token.return_value = False\n    mock_api.return_value.check_user.return_value = None\n\n    val = gh_enumeration_runner.self_enumeration()\n    assert val is False\n\n\n@patch('gatox.enumerate.enumerate.Api')\ndef test_unscoped_token(mock_api, capfd):\n    '''Test enumeration with an unscoped token.'''\n    gh_enumeration_runner = Enumerator(\n        'ghp_BADTOKEN',\n        socks_proxy=None,\n        http_proxy=None,\n        output_yaml=False,\n        skip_log=True,\n    )\n\n    mock_api.return_value.is_app_token.return_value = False\n    mock_api.return_value.check_user.return_value = {\n        'user': 'testUser',\n        'scopes': ['public_repo'],\n    }\n\n    status = gh_enumeration_runner.self_enumeration()\n    out, _ = capfd.readouterr()\n    assert 'Self-enumeration requires the repo scope!' in escape_ansi(out)\n    assert status is False\n